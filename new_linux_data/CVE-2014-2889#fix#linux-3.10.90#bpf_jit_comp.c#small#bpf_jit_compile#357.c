void bpf_jit_compile(struct sk_filter *fp)
{
	unsigned int cleanup_addr, proglen, oldproglen = 0;
	u32 temp[8], *prog, *func, seen = 0, pass;
	const struct sock_filter *filter = fp->insns;
	int i, flen = fp->len, pc_ret0 = -1;
	unsigned int *addrs;
	void *image;

	if (!bpf_jit_enable)
		return;

	addrs = kmalloc(flen * sizeof(*addrs), GFP_KERNEL);
	if (addrs == NULL)
		return;

	for (proglen = 0, i = 0; i < flen; i++) {
		proglen += 64;
		addrs[i] = proglen;
	}
	image = NULL;
	for (pass = 0; pass < 10; pass++) {
		u8 seen_or_pass0 = (pass == 0) ? (SEEN_XREG | SEEN_DATAREF | SEEN_MEM) : seen;
epilogue for trivial filters (RET something) */
		proglen = 0;
		prog = temp;

		if (seen_or_pass0) {
			if (seen_or_pass0 & SEEN_MEM) {
				unsigned int sz = BASE_STACKFRAME;
				sz += BPF_MEMWORDS * sizeof(u32);
				emit_alloc_stack(sz);
			}

			if (seen_or_pass0 & SEEN_XREG)
				emit_clear(r_X);

			if (seen_or_pass0 & SEEN_DATAREF) {
				emit_load32(r_SKB, struct sk_buff, len, r_HEADLEN);
				emit_load32(r_SKB, struct sk_buff, data_len, r_TMP);
				emit_sub(r_HEADLEN, r_TMP, r_HEADLEN);
				emit_loadptr(r_SKB, struct sk_buff, data, r_SKB_DATA);
			}
		}
		emit_reg_move(O7, r_saved_O7);

		switch (filter[0].code) {
		case BPF_S_RET_K:
		case BPF_S_LD_W_LEN:
		case BPF_S_ANC_PROTOCOL:
		case BPF_S_ANC_PKTTYPE:
		case BPF_S_ANC_IFINDEX:
		case BPF_S_ANC_MARK:
		case BPF_S_ANC_RXHASH:
		case BPF_S_ANC_VLAN_TAG:
		case BPF_S_ANC_VLAN_TAG_PRESENT:
		case BPF_S_ANC_CPU:
		case BPF_S_ANC_QUEUE:
		case BPF_S_LD_W_ABS:
		case BPF_S_LD_H_ABS:
		case BPF_S_LD_B_ABS:
			break;
		default:
		}

		for (i = 0; i < flen; i++) {
			unsigned int K = filter[i].k;
			unsigned int t_offset;
			unsigned int f_offset;
			u32 t_op, f_op;
			int ilen;

			switch (filter[i].code) {
				emit_alu_X(ADD);
				break;
				emit_alu_K(ADD, K);
				break;
				emit_alu_X(SUB);
				break;
				emit_alu_K(SUB, K);
				break;
				emit_alu_X(AND);
				break;
				emit_alu_K(AND, K);
				break;
				emit_alu_X(OR);
				break;
				emit_alu_K(OR, K);
				break;
			case BPF_S_ALU_XOR_X:
				emit_alu_X(XOR);
				break;
				emit_alu_K(XOR, K);
				break;
				emit_alu_X(SLL);
				break;
				emit_alu_K(SLL, K);
				break;
				emit_alu_X(SRL);
				break;
				emit_alu_K(SRL, K);
				break;
				emit_alu_X(MUL);
				break;
				emit_alu_K(MUL, K);
				break;= K with K != 0*/
				if (K == 1)
					break;
				emit_write_y(G0);
#ifdef CONFIG_SPARC32
				emit_nop();
				emit_nop();
				emit_nop();
#endif
				emit_alu_K(DIV, K);
				break;= X; */
				emit_cmpi(r_X, 0);
				if (pc_ret0 > 0) {
					t_offset = addrs[pc_ret0 - 1];
#ifdef CONFIG_SPARC32
					emit_branch(BE, t_offset + 20);
#else
					emit_branch(BE, t_offset + 8);
#endif
				} else {
					emit_branch_off(BNE, 16);
					emit_nop();
#ifdef CONFIG_SPARC32
					emit_jump(cleanup_addr + 20);
#else
					emit_jump(cleanup_addr + 8);
#endif
					emit_clear(r_A);
				}
				emit_write_y(G0);
#ifdef CONFIG_SPARC32
				emit_nop();
				emit_nop();
				emit_nop();
#endif
				emit_alu_X(DIV);
				break;
			case BPF_S_ALU_NEG:
				emit_neg();
				break;
			case BPF_S_RET_K:
				if (!K) {
					if (pc_ret0 == -1)
						pc_ret0 = i;
					emit_clear(r_A);
				} else {
					emit_loadimm(K, r_A);
				}
			case BPF_S_RET_A:
				if (seen_or_pass0) {
					if (i != flen - 1) {
						emit_jump(cleanup_addr);
						emit_nop();
						break;
					}
					if (seen_or_pass0 & SEEN_MEM) {
						unsigned int sz = BASE_STACKFRAME;
						sz += BPF_MEMWORDS * sizeof(u32);
						emit_release_stack(sz);
					}
				}
				emit_jmpl(r_saved_O7, 8, G0);
				break;
			case BPF_S_MISC_TAX:
				seen |= SEEN_XREG;
				emit_reg_move(r_A, r_X);
				break;
			case BPF_S_MISC_TXA:
				seen |= SEEN_XREG;
				emit_reg_move(r_X, r_A);
				break;
			case BPF_S_ANC_CPU:
				emit_load_cpu(r_A);
				break;
			case BPF_S_ANC_PROTOCOL:
				emit_skb_load16(protocol, r_A);
				break;
#if 0
			case BPF_S_ANC_PKTTYPE:
				__emit_skb_load8(pkt_type, r_A);
				emit_alu_K(SRL, 5);
				break;
#endif
			case BPF_S_ANC_IFINDEX:
				emit_skb_loadptr(dev, r_A);
				emit_cmpi(r_A, 0);
				emit_branch(BE_PTR, cleanup_addr + 4);
				emit_nop();
				emit_load32(r_A, struct net_device, ifindex, r_A);
				break;
			case BPF_S_ANC_MARK:
				emit_skb_load32(mark, r_A);
				break;
			case BPF_S_ANC_QUEUE:
				emit_skb_load16(queue_mapping, r_A);
				break;
			case BPF_S_ANC_HATYPE:
				emit_skb_loadptr(dev, r_A);
				emit_cmpi(r_A, 0);
				emit_branch(BE_PTR, cleanup_addr + 4);
				emit_nop();
				emit_load16(r_A, struct net_device, type, r_A);
				break;
			case BPF_S_ANC_RXHASH:
				emit_skb_load32(rxhash, r_A);
				break;
			case BPF_S_ANC_VLAN_TAG:
			case BPF_S_ANC_VLAN_TAG_PRESENT:
				emit_skb_load16(vlan_tci, r_A);
				if (filter[i].code == BPF_S_ANC_VLAN_TAG) {
					emit_andi(r_A, VLAN_VID_MASK, r_A);
				} else {
					emit_loadimm(VLAN_TAG_PRESENT, r_TMP);
					emit_and(r_A, r_TMP, r_A);
				}
				break;

			case BPF_S_LD_IMM:
				emit_loadimm(K, r_A);
				break;
			case BPF_S_LDX_IMM:
				emit_loadimm(K, r_X);
				break;
			case BPF_S_LD_MEM:
				emit_ldmem(K * 4, r_A);
				break;
			case BPF_S_LDX_MEM:
				emit_ldmem(K * 4, r_X);
				break;
			case BPF_S_ST:
				emit_stmem(K * 4, r_A);
				break;
			case BPF_S_STX:
				emit_stmem(K * 4, r_X);
				break;

#define CHOOSE_LOAD_FUNC(K, func) \
	((int)K < 0 ? ((int)K >= SKF_LL_OFF ? func##_negative_offset : func) : func##_positive_offset)

			case BPF_S_LD_W_ABS:
				func = CHOOSE_LOAD_FUNC(K, bpf_jit_load_word);
common_load:			seen |= SEEN_DATAREF;
				emit_loadimm(K, r_OFF);
				emit_call(func);
				break;
			case BPF_S_LD_H_ABS:
				func = CHOOSE_LOAD_FUNC(K, bpf_jit_load_half);
				goto common_load;
			case BPF_S_LD_B_ABS:
				func = CHOOSE_LOAD_FUNC(K, bpf_jit_load_byte);
				goto common_load;
			case BPF_S_LDX_B_MSH:
				func = CHOOSE_LOAD_FUNC(K, bpf_jit_load_byte_msh);
				goto common_load;
			case BPF_S_LD_W_IND:
				func = bpf_jit_load_word;
common_load_ind:		seen |= SEEN_DATAREF | SEEN_XREG;
				if (K) {
					if (is_simm13(K)) {
						emit_addi(r_X, K, r_OFF);
					} else {
						emit_loadimm(K, r_TMP);
						emit_add(r_X, r_TMP, r_OFF);
					}
				} else {
					emit_reg_move(r_X, r_OFF);
				}
				emit_call(func);
				break;
			case BPF_S_LD_H_IND:
				func = bpf_jit_load_half;
				goto common_load_ind;
			case BPF_S_LD_B_IND:
				func = bpf_jit_load_byte;
				goto common_load_ind;
			case BPF_S_JMP_JA:
				emit_jump(addrs[i + K]);
				emit_nop();
				break;

#define COND_SEL(CODE, TOP, FOP)	\
	case CODE:			\
		t_op = TOP;		\
		f_op = FOP;		\
		goto cond_branch

			COND_SEL(BPF_S_JMP_JGT_K, BGU, BLEU);
			COND_SEL(BPF_S_JMP_JGE_K, BGEU, BLU);
			COND_SEL(BPF_S_JMP_JEQ_K, BE, BNE);
			COND_SEL(BPF_S_JMP_JSET_K, BNE, BE);
			COND_SEL(BPF_S_JMP_JGT_X, BGU, BLEU);
			COND_SEL(BPF_S_JMP_JGE_X, BGEU, BLU);
			COND_SEL(BPF_S_JMP_JEQ_X, BE, BNE);
			COND_SEL(BPF_S_JMP_JSET_X, BNE, BE);

cond_branch:			f_offset = addrs[i + filter[i].jf];
				t_offset = addrs[i + filter[i].jt];

				if (filter[i].jt == filter[i].jf) {
					emit_jump(t_offset);
					emit_nop();
					break;
				}

				switch (filter[i].code) {
				case BPF_S_JMP_JGT_X:
				case BPF_S_JMP_JGE_X:
				case BPF_S_JMP_JEQ_X:
					seen |= SEEN_XREG;
					emit_cmp(r_A, r_X);
					break;
				case BPF_S_JMP_JSET_X:
					seen |= SEEN_XREG;
					emit_btst(r_A, r_X);
					break;
				case BPF_S_JMP_JEQ_K:
				case BPF_S_JMP_JGT_K:
				case BPF_S_JMP_JGE_K:
					if (is_simm13(K)) {
						emit_cmpi(r_A, K);
					} else {
						emit_loadimm(K, r_TMP);
						emit_cmp(r_A, r_TMP);
					}
					break;
				case BPF_S_JMP_JSET_K:
					if (is_simm13(K)) {
						emit_btsti(r_A, K);
					} else {
						emit_loadimm(K, r_TMP);
						emit_btst(r_A, r_TMP);
					}
					break;
				}
				if (filter[i].jt != 0) {
					if (filter[i].jf)
						t_offset += 8;
					emit_branch(t_op, t_offset);
					if (filter[i].jf) {
						emit_jump(f_offset);
						emit_nop();
					}
					break;
				}
				emit_branch(f_op, f_offset);
				break;

			default:
				goto out;
			}
			ilen = (void *) prog - (void *) temp;
			if (image) {
				if (unlikely(proglen + ilen > oldproglen)) {
					pr_err("bpb_jit_compile fatal error\n");
					kfree(addrs);
					module_free(NULL, image);
					return;
				}
				memcpy(image + proglen, temp, ilen);
			}
			proglen += ilen;
			addrs[i] = proglen;
			prog = temp;
		}
		if (seen_or_pass0 & SEEN_MEM)

		if (image) {
			if (proglen != oldproglen)
				pr_err("bpb_jit_compile proglen=%u != oldproglen=%u\n",
				       proglen, oldproglen);
			break;
		}
		if (proglen == oldproglen) {
			image = module_alloc(max_t(unsigned int,
						   proglen,
						   sizeof(struct work_struct)));
			if (!image)
				goto out;
		}
		oldproglen = proglen;
	}

	if (bpf_jit_enable > 1)
		bpf_jit_dump(flen, proglen, pass, image);

	if (image) {
		bpf_flush_icache(image, image + proglen);
		fp->bpf_func = (void *)image;
	}
out:
	kfree(addrs);
	return;
}
