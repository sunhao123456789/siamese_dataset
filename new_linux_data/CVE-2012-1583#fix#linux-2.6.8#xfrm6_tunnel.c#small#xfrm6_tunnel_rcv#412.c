static int xfrm6_tunnel_rcv(struct sk_buff **pskb, unsigned int *nhoffp)
{
	struct sk_buff *skb = *pskb;
	struct xfrm6_tunnel *handler = xfrm6_tunnel_handler;
	struct xfrm_state *x = NULL;
	struct ipv6hdr *iph = skb->nh.ipv6h;
	int err = 0;
	u32 spi;

	if (handler) {
		err = handler->handler(pskb, nhoffp);
		if (!err)
			goto out;
	}

	spi = xfrm6_tunnel_spi_lookup((xfrm_address_t *)&iph->saddr);
	x = xfrm_state_lookup((xfrm_address_t *)&iph->daddr, 
			spi,
			IPPROTO_IPV6, AF_INET6);

	if (!x)
		goto drop;

	spin_lock(&x->lock);

	if (unlikely(x->km.state != XFRM_STATE_VALID))
		goto drop_unlock;

	err = xfrm6_tunnel_input(x, NULL, skb);
	if (err)
		goto drop_unlock;

	x->curlft.bytes += skb->len;
	x->curlft.packets++; 
	spin_unlock(&x->lock); 
	xfrm_state_put(x); 

out:
	return 0;

drop_unlock:
	spin_unlock(&x->lock);
	xfrm_state_put(x);
drop:
	kfree_skb(skb);
	return -1;
}
