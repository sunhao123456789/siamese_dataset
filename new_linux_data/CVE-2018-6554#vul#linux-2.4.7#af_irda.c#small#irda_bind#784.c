static int irda_bind(struct socket *sock, struct sockaddr *uaddr, int addr_len)
{
	struct sock *sk = sock->sk;
	struct sockaddr_irda *addr = (struct sockaddr_irda *) uaddr;
	struct irda_sock *self;
	int err;

	self = sk->protinfo.irda;
	ASSERT(self != NULL, return -1;);

	IRDA_DEBUG(2, "%s(%p)\n", __FUNCTION__, self);

	if (addr_len != sizeof(struct sockaddr_irda))
		return -EINVAL;

#ifdef CONFIG_IRDA_ULTRA
	if ((sk->type == SOCK_DGRAM) && (sk->protocol == IRDAPROTO_ULTRA)) {
		self->pid = addr->sir_lsap_sel;
		if (self->pid & 0x80) {
			IRDA_DEBUG(0, "%s(), extension in PID not supp!\n", __FUNCTION__);
			return -EOPNOTSUPP;
		}
		err = irda_open_lsap(self, self->pid);
		if (err < 0)
			return err;
		
		self->max_data_size = ULTRA_MAX_DATA - LMP_PID_HEADER;
		self->max_header_size = IRDA_MAX_HEADER + LMP_PID_HEADER;

		sock->state = SS_CONNECTED;
		sk->state   = TCP_ESTABLISHED;

		return 0;
	}

	err = irda_open_tsap(self, addr->sir_lsap_sel, addr->sir_name);
	if (err < 0)
		return err;
	
	self->ias_obj = irias_new_object(addr->sir_name, jiffies);
	irias_add_integer_attrib(self->ias_obj, "IrDA:TinyTP:LsapSel", 
				 self->stsap_sel, IAS_KERNEL_ATTR);
	irias_insert_object(self->ias_obj);
	
	return 0;
}
