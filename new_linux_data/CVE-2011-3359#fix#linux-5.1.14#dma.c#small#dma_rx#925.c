int dma_rx(struct dma_pub *pub, struct sk_buff_head *skb_list)
{
	struct dma_info *di = container_of(pub, struct dma_info, dma);
	struct sk_buff_head dma_frames;
	struct sk_buff *p, *next;
	uint len;
	uint pkt_len;
	int resid = 0;
	int pktcnt = 1;

	skb_queue_head_init(&dma_frames);
 next_frame:
	p = _dma_getnextrxp(di, false);
	if (p == NULL)
		return 0;

	len = le16_to_cpu(*(__le16 *) (p->data));
	brcms_dbg_dma(di->core, "%s: dma_rx len %d\n", di->name, len);
	dma_spin_for_len(len, p);

	pkt_len = min((di->rxoffset + len), di->rxbufsize);
	__skb_trim(p, pkt_len);
	skb_queue_tail(&dma_frames, p);
	resid = len - (di->rxbufsize - di->rxoffset);

	if (resid > 0) {
		while ((resid > 0) && (p = _dma_getnextrxp(di, false))) {
			pkt_len = min_t(uint, resid, di->rxbufsize);
			__skb_trim(p, pkt_len);
			skb_queue_tail(&dma_frames, p);
			resid -= di->rxbufsize;
			pktcnt++;
		}

#ifdef DEBUG
		if (resid > 0) {
			uint cur;
			cur =
			    B2I(((bcma_read32(di->core,
					      DMA64RXREGOFFS(di, status0)) &
				  D64_RS0_CD_MASK) - di->rcvptrbase) &
				D64_RS0_CD_MASK, struct dma64desc);
			brcms_dbg_dma(di->core,
				      "rxin %d rxout %d, hw_curr %d\n",
				      di->rxin, di->rxout, cur);
		}

		if ((di->dma.dmactrlflags & DMA_CTRL_RXMULTI) == 0) {
			brcms_dbg_dma(di->core, "%s: bad frame length (%d)\n",
				      di->name, len);
			skb_queue_walk_safe(&dma_frames, p, next) {
				skb_unlink(p, &dma_frames);
				brcmu_pkt_buf_free_skb(p);
			}
			di->dma.rxgiants++;
			pktcnt = 1;
			goto next_frame;
		}
	}

	skb_queue_splice_tail(&dma_frames, skb_list);
	return pktcnt;
}
