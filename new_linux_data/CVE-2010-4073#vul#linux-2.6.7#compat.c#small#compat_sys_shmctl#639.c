long compat_sys_shmctl(int first, int second, void __user *uptr)
{
	struct shmid64_ds s64;
	struct shminfo64 smi;
	struct shm_info si;
	int err, err2;
	int version = compat_ipc_parse_version(&second);

	switch (second & (~IPC_64)) {
	case IPC_RMID:
	case SHM_LOCK:
	case SHM_UNLOCK:
		err = sys_shmctl(first, second, uptr);
		break;

	case IPC_INFO:
		err = do_shmctl(first, second, &smi);
		if (err < 0)
			break;

		if (version == IPC_64) {
			err2 = put_compat_shminfo64(&smi, uptr);
		} else {
			err2 = put_compat_shminfo(&smi, uptr);
		}
		if (err2)
			err = -EFAULT;
		break;


	case IPC_SET:
		if (version == IPC_64) {
			err = get_compat_shmid64_ds(&s64, uptr);
		} else {
			err = get_compat_shmid_ds(&s64, uptr);
		}
		if (err)
			break;

		err = do_shmctl(first, second, &s64);
		break;

	case IPC_STAT:
	case SHM_STAT:
		err = do_shmctl(first, second, &s64);
		if (err < 0)
			break;

		if (version == IPC_64) {
			err2 = put_compat_shmid64_ds(&s64, uptr);
		} else {
			err2 = put_compat_shmid_ds(&s64, uptr);
		}
		if (err2)
			err = -EFAULT;
		break;

	case SHM_INFO:
		err = do_shmctl(first, second, &si);
		if (err < 0)
			break;
		err2 = put_compat_shm_info(&si, uptr);
		if (err2)
			err = -EFAULT;
		break;

	default:
		err = -EINVAL;
		break;
	}
	return err;
}
