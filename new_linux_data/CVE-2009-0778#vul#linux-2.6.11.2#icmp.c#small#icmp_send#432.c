void icmp_send(struct sk_buff *skb_in, int type, int code, u32 info)
{
	struct iphdr *iph;
	int room;
	struct icmp_bxm icmp_param;
	struct rtable *rt = (struct rtable *)skb_in->dst;
	struct ipcm_cookie ipc;
	u32 saddr;
	u8  tos;

	if (!rt)
		goto out;

	iph = skb_in->nh.iph;

	if ((u8 *)iph < skb_in->head || (u8 *)(iph + 1) > skb_in->tail)
		goto out;
broadcast*
	 *	Now check at the protocol level*
	 *	Only reply to fragment 0. We byte re-order the constant
	 *	mask for efficiency.*
	 *	If we send an ICMP error to an ICMP error a mess would result..*
		 *	We are an error, check if we are replying to an
		 *	ICMP error*
			 *	Assume any unknown ICMP type is an error. This
			 *	isn't specified by the RFC, but think about it..*
	 *	Construct source address and options.*
	 *	Prepare data for ICMP header.* RFC says return as much as we can without exceeding 576 bytes. */

	room = dst_pmtu(&rt->u.dst);
	if (room > 576)
		room = 576;
	room -= sizeof(struct iphdr) + icmp_param.replyopts.optlen;
	room -= sizeof(struct icmphdr);

	icmp_param.data_len = skb_in->len - icmp_param.offset;
	if (icmp_param.data_len > room)
		icmp_param.data_len = room;
	icmp_param.head_len = sizeof(struct icmphdr);

	icmp_push_reply(&icmp_param, &ipc, rt);
ende:
	ip_rt_put(rt);
out_unlock:
	icmp_xmit_unlock();
out:;
}
