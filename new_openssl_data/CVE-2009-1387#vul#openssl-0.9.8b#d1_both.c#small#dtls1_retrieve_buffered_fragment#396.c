static int
dtls1_retrieve_buffered_fragment(SSL *s, unsigned long *copied)
    {
    /* (0) check whether the desired fragment is available
     * if so:
     * (1) copy over the fragment to s->init_buf->data[]
     * (2) update s->init_num
     */
    pitem *item;
    hm_fragment *frag;
    unsigned long overlap;
    unsigned char *p;

    item = pqueue_peek(s->d1->buffered_messages);
    if ( item == NULL)
        return 0;

    frag = (hm_fragment *)item->data;
    
    if ( s->d1->handshake_read_seq == frag->msg_header.seq &&
        frag->msg_header.frag_off <= (unsigned int)s->init_num - DTLS1_HM_HEADER_LENGTH)
        {
        pqueue_pop(s->d1->buffered_messages);
        overlap = s->init_num - DTLS1_HM_HEADER_LENGTH 
            - frag->msg_header.frag_off;

        p = frag->fragment;

        memcpy(&s->init_buf->data[s->init_num],
            p + DTLS1_HM_HEADER_LENGTH + overlap,
            frag->msg_header.frag_len - overlap);
    
        OPENSSL_free(frag->fragment);
        OPENSSL_free(frag);
        pitem_free(item);

        *copied = frag->msg_header.frag_len - overlap;
        return *copied;
        }
    else
        return 0;
    }
