static int
dtls1_process_out_of_seq_message(SSL *s, struct hm_header_st *msg_hdr, int *ok)
    {
    int i;
    unsigned char *p;

    /* make sure there's enough room to read this fragment */
    if ( (int)msg_hdr->frag_len && !BUF_MEM_grow_clean(s->init_buf, 
             (int)msg_hdr->frag_len + DTLS1_HM_HEADER_LENGTH + s->init_num))
        {
        SSLerr(SSL_F_DTLS1_PROCESS_OUT_OF_SEQ_MESSAGE,ERR_R_BUF_LIB);
        goto err;
        }

    p = (unsigned char *)s->init_buf->data;

    /* read the body of the fragment (header has already been read */
    if ( msg_hdr->frag_len > 0)
		{
		i=s->method->ssl_read_bytes(s,SSL3_RT_HANDSHAKE,
            &p[s->init_num], 
            msg_hdr->frag_len,0);
		if (i <= 0)
			{
			*ok = 0;
			return i;
			}
		}

    if ( msg_hdr->seq > s->d1->handshake_read_seq)
        dtls1_buffer_handshake_fragment(s, msg_hdr);
    else
        OPENSSL_assert(msg_hdr->seq < s->d1->handshake_read_seq);

    return DTLS1_HM_FRAGMENT_RETRY;
err:
    *ok = 0;
    return -1;
    }
