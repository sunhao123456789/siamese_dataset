void bpf_jit_compile(struct sk_filter *fp)
{
	unsigned long size, prg_len, lit_len;
	struct bpf_jit jit, cjit;
	unsigned int *addrs;
	int pass, i;

	if (!bpf_jit_enable)
		return;
	addrs = kcalloc(fp->len, sizeof(*addrs), GFP_KERNEL);
	if (addrs == NULL)
		return;
	memset(&jit, 0, sizeof(cjit));
	memset(&cjit, 0, sizeof(cjit));

	for (pass = 0; pass < 10; pass++) {
		jit.prg = jit.start;
		jit.lit = jit.mid;

		bpf_jit_prologue(&jit);
		bpf_jit_noleaks(&jit, fp->insns);
		for (i = 0; i < fp->len; i++) {
			if (bpf_jit_insn(&jit, fp->insns + i, addrs, i,
					 i == fp->len - 1))
				goto out;
		}
		bpf_jit_epilogue(&jit);
		if (jit.start) {
			WARN_ON(jit.prg > cjit.prg || jit.lit > cjit.lit);
			if (memcmp(&jit, &cjit, sizeof(jit)) == 0)
				break;
		} else if (jit.prg == cjit.prg && jit.lit == cjit.lit) {
			prg_len = jit.prg - jit.start;
			lit_len = jit.lit - jit.mid;
			size = max_t(unsigned long, prg_len + lit_len,
				     sizeof(struct work_struct));
			if (size >= BPF_SIZE_MAX)
				goto out;
			jit.start = module_alloc(size);
			if (!jit.start)
				goto out;
			jit.prg = jit.mid = jit.start + prg_len;
			jit.lit = jit.end = jit.start + prg_len + lit_len;
			jit.base_ip += (unsigned long) jit.start;
			jit.exit_ip += (unsigned long) jit.start;
			jit.ret0_ip += (unsigned long) jit.start;
		}
		cjit = jit;
	}
	if (bpf_jit_enable > 1) {
		pr_err("flen=%d proglen=%lu pass=%d image=%p\n",
		       fp->len, jit.end - jit.start, pass, jit.start);
		if (jit.start) {
			printk(KERN_ERR "JIT code:\n");
			print_fn_code(jit.start, jit.mid - jit.start);
			print_hex_dump(KERN_ERR, "JIT literals:\n",
				       DUMP_PREFIX_ADDRESS, 16, 1,
				       jit.mid, jit.end - jit.mid, false);
		}
	}
	if (jit.start)
		fp->bpf_func = (void *) jit.start;
out:
	kfree(addrs);
}
