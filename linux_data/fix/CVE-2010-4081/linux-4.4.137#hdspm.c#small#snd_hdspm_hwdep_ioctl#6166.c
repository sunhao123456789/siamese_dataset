static int snd_hdspm_hwdep_ioctl(struct snd_hwdep *hw, struct file *file,
		unsigned int cmd, unsigned long arg)
{
	void __user *argp = (void __user *)arg;
	struct hdspm *hdspm = hw->private_data;
	struct hdspm_mixer_ioctl mixer;
	struct hdspm_config info;
	struct hdspm_status status;
	struct hdspm_version hdspm_version;
	struct hdspm_peak_rms *levels;
	struct hdspm_ltc ltc;
	unsigned int statusregister;
	long unsigned int s;
	int i = 0;

	switch (cmd) {

	case SNDRV_HDSPM_IOCTL_GET_PEAK_RMS:
		levels = &hdspm->peak_rms;
		for (i = 0; i < HDSPM_MAX_CHANNELS; i++) {
			levels->input_peaks[i] =
				readl(hdspm->iobase +
						HDSPM_MADI_INPUT_PEAK + i*4);
			levels->playback_peaks[i] =
				readl(hdspm->iobase +
						HDSPM_MADI_PLAYBACK_PEAK + i*4);
			levels->output_peaks[i] =
				readl(hdspm->iobase +
						HDSPM_MADI_OUTPUT_PEAK + i*4);

			levels->input_rms[i] =
				((uint64_t) readl(hdspm->iobase +
					HDSPM_MADI_INPUT_RMS_H + i*4) << 32) |
				(uint64_t) readl(hdspm->iobase +
						HDSPM_MADI_INPUT_RMS_L + i*4);
			levels->playback_rms[i] =
				((uint64_t)readl(hdspm->iobase +
					HDSPM_MADI_PLAYBACK_RMS_H+i*4) << 32) |
				(uint64_t)readl(hdspm->iobase +
					HDSPM_MADI_PLAYBACK_RMS_L + i*4);
			levels->output_rms[i] =
				((uint64_t)readl(hdspm->iobase +
					HDSPM_MADI_OUTPUT_RMS_H + i*4) << 32) |
				(uint64_t)readl(hdspm->iobase +
						HDSPM_MADI_OUTPUT_RMS_L + i*4);
		}

		if (hdspm->system_sample_rate > 96000) {
			levels->speed = qs;
		} else if (hdspm->system_sample_rate > 48000) {
			levels->speed = ds;
		} else {
			levels->speed = ss;
		}
		levels->status2 = hdspm_read(hdspm, HDSPM_statusRegister2);

		s = copy_to_user(argp, levels, sizeof(struct hdspm_peak_rms));
		if (0 != s) {
			return -EFAULT;
		}
		break;

	case SNDRV_HDSPM_IOCTL_GET_LTC:
		ltc.ltc = hdspm_read(hdspm, HDSPM_RD_TCO);
		i = hdspm_read(hdspm, HDSPM_RD_TCO + 4);
		if (i & HDSPM_TCO1_LTC_Input_valid) {
			switch (i & (HDSPM_TCO1_LTC_Format_LSB |
				HDSPM_TCO1_LTC_Format_MSB)) {
			case 0:
				ltc.format = fps_24;
				break;
			case HDSPM_TCO1_LTC_Format_LSB:
				ltc.format = fps_25;
				break;
			case HDSPM_TCO1_LTC_Format_MSB:
				ltc.format = fps_2997;
				break;
			default:
				ltc.format = fps_30;
				break;
			}
			if (i & HDSPM_TCO1_set_drop_frame_flag) {
				ltc.frame = drop_frame;
			} else {
				ltc.frame = full_frame;
			}
		} else {
			ltc.format = format_invalid;
			ltc.frame = frame_invalid;
		}
		if (i & HDSPM_TCO1_Video_Input_Format_NTSC) {
			ltc.input_format = ntsc;
		} else if (i & HDSPM_TCO1_Video_Input_Format_PAL) {
			ltc.input_format = pal;
		} else {
			ltc.input_format = no_video;
		}

		s = copy_to_user(argp, &ltc, sizeof(struct hdspm_ltc));
		if (0 != s) {
			return -EFAULT;
		}

		break;

	case SNDRV_HDSPM_IOCTL_GET_CONFIG:

		memset(&info, 0, sizeof(info));
		spin_lock_irq(&hdspm->lock);
		info.pref_sync_ref = hdspm_pref_sync_ref(hdspm);
		info.wordclock_sync_check = hdspm_wc_sync_check(hdspm);

		info.system_sample_rate = hdspm->system_sample_rate;
		info.autosync_sample_rate =
			hdspm_external_sample_rate(hdspm);
		info.system_clock_mode = hdspm_system_clock_mode(hdspm);
		info.clock_source = hdspm_clock_source(hdspm);
		info.autosync_ref = hdspm_autosync_ref(hdspm);
		info.line_out = hdspm_toggle_setting(hdspm, HDSPM_LineOut);
		info.passthru = 0;
		spin_unlock_irq(&hdspm->lock);
		if (copy_to_user(argp, &info, sizeof(info)))
			return -EFAULT;
		break;

	case SNDRV_HDSPM_IOCTL_GET_STATUS:
		memset(&status, 0, sizeof(status));

		status.card_type = hdspm->io_type;

		status.autosync_source = hdspm_autosync_ref(hdspm);

		status.card_clock = 110069313433624ULL;
		status.master_period = hdspm_read(hdspm, HDSPM_RD_PLL_FREQ);

		switch (hdspm->io_type) {
		case MADI:
		case MADIface:
			status.card_specific.madi.sync_wc =
				hdspm_wc_sync_check(hdspm);
			status.card_specific.madi.sync_madi =
				hdspm_madi_sync_check(hdspm);
			status.card_specific.madi.sync_tco =
				hdspm_tco_sync_check(hdspm);
			status.card_specific.madi.sync_in =
				hdspm_sync_in_sync_check(hdspm);

			statusregister =
				hdspm_read(hdspm, HDSPM_statusRegister);
			status.card_specific.madi.madi_input =
				(statusregister & HDSPM_AB_int) ? 1 : 0;
			status.card_specific.madi.channel_format =
				(statusregister & HDSPM_RX_64ch) ? 1 : 0;
			status.card_specific.madi.frame_format = 0;

		default:
			break;
		}

		if (copy_to_user(argp, &status, sizeof(status)))
			return -EFAULT;


		break;

	case SNDRV_HDSPM_IOCTL_GET_VERSION:
		memset(&hdspm_version, 0, sizeof(hdspm_version));

		hdspm_version.card_type = hdspm->io_type;
		strlcpy(hdspm_version.cardname, hdspm->card_name,
				sizeof(hdspm_version.cardname));
		hdspm_version.serial = hdspm->serial;
		hdspm_version.firmware_rev = hdspm->firmware_rev;
		hdspm_version.addons = 0;
		if (hdspm->tco)
			hdspm_version.addons |= HDSPM_ADDON_TCO;

		if (copy_to_user(argp, &hdspm_version,
					sizeof(hdspm_version)))
			return -EFAULT;
		break;

	case SNDRV_HDSPM_IOCTL_GET_MIXER:
		if (copy_from_user(&mixer, argp, sizeof(mixer)))
			return -EFAULT;
		if (copy_to_user((void __user *)mixer.mixer, hdspm->mixer,
					sizeof(struct hdspm_mixer)))
			return -EFAULT;
		break;

	default:
		return -EINVAL;
	}
	return 0;
}
