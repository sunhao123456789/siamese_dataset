int parse_rock_ridge_inode_internal(struct iso_directory_record * de,
			            struct inode * inode,int regard_xa){
  int len;
  unsigned char * chr;
  int symlink_len = 0;
  CONTINUE_DECLS;

  if (!inode->i_sb->u.isofs_sb.s_rock) return 0;

  SETUP_ROCK_RIDGE(de, chr, len);
  if (regard_xa)
   {
     chr+=14;
     len-=14;
     if (len<0) len=0;
   };
   
 repeat:
  {
    int cnt, sig;
    struct inode * reloc;
    struct rock_ridge * rr;
    int rootflag;
    
      rr = (struct rock_ridge *) chr;
      sig = isonum_721(chr);
      chr += rr->len; 
      len -= rr->len;
      
      switch(sig){
      case SIG('R','R'):
	if((rr->u.RR.flags[0] & 
 	    (RR_PX | RR_TF | RR_SL | RR_CL)) == 0) goto out;
	break;
#endif
      case SIG('S','P'):
	CHECK_SP(goto out);
	break;
      case SIG('C','E'):
	CHECK_CE;
	break;
      case SIG('E','R'):
	inode->i_sb->u.isofs_sb.s_rock = 1;
	printk(KERN_DEBUG "ISO 9660 Extensions: ");
	{ int p;
	  for(p=0;p<rr->u.ER.len_id;p++) printk("%c",rr->u.ER.data[p]);
	}
	  printk("\n");
	break;
      case SIG('P','X'):
	inode->i_mode  = isonum_733(rr->u.PX.mode);
	inode->i_nlink = isonum_733(rr->u.PX.n_links);
	inode->i_uid   = isonum_733(rr->u.PX.uid);
	inode->i_gid   = isonum_733(rr->u.PX.gid);
	break;
      case SIG('P','N'):
	{ int high, low;
	  high = isonum_733(rr->u.PN.dev_high);
	  low = isonum_733(rr->u.PN.dev_low);
	  if((low & ~0xff) && high == 0) {
	    inode->i_rdev = MKDEV(low >> 8, low & 0xff);
	  } else {
	    inode->i_rdev = MKDEV(high, low);
	  }
	}
	break;
      case SIG('T','F'):
	if(rr->u.TF.flags & TF_CREATE) 
	  inode->i_ctime = iso_date(rr->u.TF.times[cnt++].time, 0);
	if(rr->u.TF.flags & TF_MODIFY) 
	  inode->i_mtime = iso_date(rr->u.TF.times[cnt++].time, 0);
	if(rr->u.TF.flags & TF_ACCESS) 
	  inode->i_atime = iso_date(rr->u.TF.times[cnt++].time, 0);
	if(rr->u.TF.flags & TF_ATTRIBUTES) 
	  inode->i_ctime = iso_date(rr->u.TF.times[cnt++].time, 0);
	break;
      case SIG('S','L'):
	{int slen;
	 struct SL_component * slp;
	 struct SL_component * oldslp;
	 slen = rr->len - 5;
	 slp = &rr->u.SL.link;
	 inode->i_size = symlink_len;
	 while (slen > 1){
	   rootflag = 0;
	   switch(slp->flags &~1){
	   case 0:
	     inode->i_size += slp->len;
	     break;
	   case 2:
	     inode->i_size += 1;
	     break;
	   case 4:
	     inode->i_size += 2;
	     break;
	   case 8:
	     rootflag = 1;
	     inode->i_size += 1;
	     break;
	   default:
	     printk("Symlink component flag not implemented\n");
	   }
	   slen -= slp->len + 2;
	   oldslp = slp;
	   slp = (struct SL_component *) (((char *) slp) + slp->len + 2);

	   if(slen < 2) {
	     if(    ((rr->u.SL.flags & 1) != 0) 
		    && ((oldslp->flags & 1) == 0) ) inode->i_size += 1;
	     break;
	   }
'.* Note: we don't change i_blocks here */
				      inode->u.isofs_i.i_file_format = isofs_file_compressed;
				      inode->u.isofs_i.i_format_parm[0] = isonum_711(&rr->u.ZF.parms[0]);
				      inode->u.isofs_i.i_format_parm[1] = isonum_711(&rr->u.ZF.parms[1]);
				      inode->i_size = isonum_733(rr->u.ZF.real_size);
			      }
		      } else {
			      printk(KERN_WARNING "isofs: Unknown ZF compression algorithm: %c%c\n",
				     rr->u.ZF.algorithm[0], rr->u.ZF.algorithm[1]);
		      }
	      }
	      break;
#endif
      default:
	break;
      }
    }
  }
  MAYBE_CONTINUE(repeat,inode);
  return 0;
 out:
  if(buffer) kfree(buffer);
  return 0;
}
