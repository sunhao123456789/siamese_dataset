int drm_modeset_ctl(struct drm_device *dev, void *data,
		    struct drm_file *file_priv)
{
	struct drm_modeset_ctl *modeset = data;
	unsigned long irqflags;
	int crtc, ret = 0;

	if (!dev->num_crtcs)
		goto out;

	crtc = modeset->crtc;
	if (crtc >= dev->num_crtcs) {
		ret = -EINVAL;
		goto out;
	}
disabled around or between these calls, we just
	 * have the kernel take a reference on the CRTC (just once though
	 * to avoid corrupting the count if multiple, mismatch calls occur),
	 * so that interrupts remain enabled in the interim.
	 */
	switch (modeset->cmd) {
	case _DRM_PRE_MODESET:
		if (!dev->vblank_inmodeset[crtc]) {
			dev->vblank_inmodeset[crtc] = 1;
			drm_vblank_get(dev, crtc);
		}
		break;
	case _DRM_POST_MODESET:
		if (dev->vblank_inmodeset[crtc]) {
			spin_lock_irqsave(&dev->vbl_lock, irqflags);
			dev->vblank_disable_allowed = 1;
			dev->vblank_inmodeset[crtc] = 0;
			spin_unlock_irqrestore(&dev->vbl_lock, irqflags);
			drm_vblank_put(dev, crtc);
		}
		break;
	default:
		ret = -EINVAL;
		break;
	}

out:
	return ret;
}
