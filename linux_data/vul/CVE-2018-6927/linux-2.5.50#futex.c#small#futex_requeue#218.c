static inline int futex_requeue(unsigned long uaddr1, int offset1,
	unsigned long uaddr2, int offset2, int nr_wake, int nr_requeue)
{
	struct list_head *i, *next, *head1, *head2;
	struct page *page1 = NULL, *page2 = NULL;
	int ret = 0;

	lock_futex_mm();

	page1 = __pin_page(uaddr1 - offset1);
	if (!page1)
		goto out;
	page2 = __pin_page(uaddr2 - offset2);
	if (!page2)
		goto out;

	head1 = hash_futex(page1, offset1);
	head2 = hash_futex(page2, offset2);

	list_for_each_safe(i, next, head1) {
		struct futex_q *this = list_entry(i, struct futex_q, list);

		if (this->page == page1 && this->offset == offset1) {
			list_del_init(i);
			__detach_vcache(&this->vcache);
			if (++ret <= nr_wake) {
				wake_up_all(&this->waiters);
				if (this->filp)
					send_sigio(&this->filp->f_owner,
							this->fd, POLL_IN);
			} else {
				put_page(this->page);
				__pin_page_atomic (page2);
				list_add_tail(i, head2);
				__attach_vcache(&this->vcache, uaddr2,
					current->mm, futex_vcache_callback);
				this->offset = offset2;
				this->page = page2;
				if (ret - nr_wake >= nr_requeue)
					break;
			}
		}
	}

out:
	unlock_futex_mm();

	if (page1)
		put_page(page1);
	if (page2)
		put_page(page2);

	return ret;
}
